
### 1. 引用计数 (Reference Count) —— 为什么父进程 `close` 了，连接不断？

**Q：PPT里有吗？**
**A：** PPT里没有专门一页讲“引用计数”的定义，但在 **第4章并发服务器的代码逻辑** 中，它是**隐性核心**。

在PPT第28页的并发服务器代码中，有这样一段逻辑：
> “The parent closes the connected socket since the child handles the new client.” 
> （父进程关闭已连接套接字，因为子进程在处理这个客户端。）

**深度解释：**
想象**文件描述符 (connfd)** 是一个“遥控器”**，而底层的**TCP连接**是**“电视机”。
1.  **初始状态：** 父进程 `accept` 后，手里拿了一个遥控器（引用计数 = 1），控制这台电视。
2.  **Fork 之后：** `fork` 会复制父进程的所有资源，包括文件描述符表。这意味着子进程手里也多了一个**一模一样**的遥控器。
    * 此时，这台电视被 **2个** 遥控器控制着。
    * 内核里这台电视的 **引用计数 (Reference Count) = 2**。
3.  **父进程 close：** 父进程调用 `close(connfd)`，只是**扔掉了自己手里的那个遥控器**。
    * 引用计数从 2 变成 1。
    * 因为计数 **不为 0**，内核判断“还有人用呢”，所以**不会**关闭电视机（不会发送 FIN 包断开 TCP 连接）。
4.  **子进程处理完：** 子进程最后也 `close` 或者 `exit`，它手里的遥控器也扔了。
    * 引用计数从 1 变成 0。
    * 内核一看：“没人看了”，这就真的把电视机关了（发送 FIN 包）。

**一句话总结：** `close` 只有在引用计数减到 0 时，才会真正断开连接。这就是为什么多进程服务器里，父进程必须关掉 `connfd`，否则计数永远降不到0，导致内存泄漏。

---

### 2. 边界 (Boundary) —— 快递包裹 vs. 自来水流

**Q：什么是保留边界、无边界？**

* **UDP (保留边界 / Message Boundaries)：**
    * **比喻：** 像**寄快递包裹**。
    * 你发一个包裹（500字节），对方就收到一个包裹（500字节）。
    * 对方不可能一次收到半个包裹，也不可能把两个包裹混在一起收。
    * **“有边界”**：如果你连发 5 次 `sendto`，对方必须调 5 次 `recvfrom`，哪怕每次只发了 1 个字节，也是 5 个独立的包。

* **TCP (无边界 / Byte-stream)：**
    * **比喻：** 像**水管里的自来水**。
    * 你把一杯水（消息A）倒进管子，紧接着又倒了一盆水（消息B）。
    * 在接收端看来，就是哗啦啦流出来的水。他不知道哪滴水属于第一杯，哪滴水属于第一盆。他可能一次接了一桶水（包含A和B的一部分），也可能只接了一口水。
    * **“无边界”**：你调 10 次 `write` 写入数据，接收端可能调 1 次 `read` 就全读出来了，也可能调 20 次才读完。这就是“粘包”的原因。
    * **解决：** 所以在应用题里，你需要自己设计协议（比如先发一个长度整数），人工制造“边界”。

---

### 3. 线程栈、SP、栈帧 —— 每个人都要有自己的“草稿纸”

**Q：线程独立的栈是个啥？SP又是啥？**

* **栈 (Stack) = 这里的“草稿纸”**
    * 程序运行时，需要一块内存来记录：“我现在执行到哪个函数了？”“这个函数的局部变量 `int i` 是多少？”
    * **为什么线程要独立栈？**
        * 线程A在执行 `funcA()`，线程B在执行 `funcB()`。
        * 如果他们共用一张草稿纸，A写了个 `i=1`，B写了个 `i=100`，A再回头看 `i` 变成了100，程序就乱套了。
        * 所以，虽然堆（Heap，存 malloc 的东西）和全局变量是大家共用的，但**记录函数调用过程的栈**必须人手一份。

* **SP (Stack Pointer) = “手指”**
    * **寄存器 (Register)** 是CPU内部极快的存储单元。
    * **SP 寄存器** 就像你的手指，永远指着当前草稿纸写到的最后一行（栈顶）。
    * 当线程切换时，CPU要把“手指”移开，去指另一个线程的草稿纸。所以每个线程也要有自己独立的寄存器上下文。

* **栈帧 (Stack Frame) = “草稿纸上的一页”**
    * 每次你调用一个函数（比如 `main` 调 `doit`），栈上就会新开辟一块区域，专门存 `doit` 的参数、返回地址和局部变量。这一块区域就叫一个**栈帧**。
    * `doit` 返回了，这块栈帧就被“撕掉”（释放）了。

---

### 4. 僵尸进程 (Zombie Process) —— 为什么死了还要占坑？

**Q：系统讲讲这是啥？**


**生动理解：**
* **进程终止：** 子进程调用 `exit()` 死了。它的代码、内存、打开的文件都已经被内核释放了。它已经不能干活了。
* **变成僵尸：** 但是！它在操作系统里的“户口本”（进程表项，Process Table Entry）还没注销。它只剩下一个 PID 和一个退出状态码（比如“我是正常退出的”还是“被报错杀死的”）。
* **为什么要保留？**
    * 因为 Linux 规定：**父进程有义务知道子进程是怎么死的**。
    * 那个“尸体”（户口本）是留给父进程看的“死亡报告”。
* **怎么清理？**
    * 父进程必须调用 `wait()` 或 `waitpid()`。这就相当于父进程去派出所看了一眼死亡报告，签个字。
    * 内核看到父进程已阅，才会把这个“僵尸”彻底从进程表里抹去。
* **危害：** 如果父进程只管生不管埋（不调 `wait`），僵尸就会越来越多。系统的 PID 号（通常最大 32768 个）是有限的。僵尸多了，PID 被占光了，系统就再也创建不了新进程了（连 `ls` 命令都敲不出来），服务器就崩了。

**复习重点：**
* **SIGCHLD 信号：** 子进程死的时候，内核会发这个信号通知父进程：“你儿子挂了，快来收尸”。
* **Signal Handler：** 我们要在父进程里捕获这个信号，在信号处理函数里调用 `waitpid` 来清理僵尸。
